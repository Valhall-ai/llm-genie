/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["LLMGenie"] = factory();
	else
		root["LLMGenie"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/classes/format-validator.ts":
/*!*****************************************!*\
  !*** ./src/classes/format-validator.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nclass FormatValidator {\r\n    constructor() {\r\n        this.test = true;\r\n    }\r\n    numberedList(input, defaults = {}) {\r\n        console.debug('numberedList\\n', input, defaults);\r\n        if (typeof input !== 'string') {\r\n            throw new Error('Bad input supplied to numberedList: ' + input);\r\n        }\r\n        else if (!input)\r\n            return false;\r\n        input = input.trim();\r\n        let lines = input.split(/\\n+/); // Allow multiple line breaks between items\r\n        let list = [];\r\n        let valid = true;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            let line = lines[i].trim();\r\n            let regex = new RegExp(`^${i + 1}\\\\.?\\\\s+([\\\\s\\\\S]+)$`, 'm'); // Add multiline flag and support for multiline input\r\n            let match = line.match(regex);\r\n            if (match) {\r\n                list.push(match[1]);\r\n            }\r\n            else if (line === '') {\r\n                continue; // Ignore empty lines\r\n            }\r\n            else {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        console.debug('defaults', defaults);\r\n        if (defaults.constrainedChoices) {\r\n            console.debug('DEBUG defaults.constrainedChoices', defaults.constrainedChoices);\r\n            if (!this.constrainedArray(list, defaults.constrainedChoices, {\r\n                singleChoice: defaults.singleChoice\r\n            })) {\r\n                valid = false;\r\n            }\r\n        }\r\n        return valid ? { list } : false;\r\n    }\r\n    bulletedList(input, defaults) {\r\n        console.debug('bulletedList\\n', input, defaults);\r\n        if (!input)\r\n            return false;\r\n        input = input.trim();\r\n        let lines = input.split(/\\n+/); // Allow multiple line breaks between items\r\n        let list = [];\r\n        let valid = true;\r\n        for (let line of lines) {\r\n            line = line.trim();\r\n            let regex = /^[-*+]\\s+([\\s\\S]+)$/m; // Match \"-\", \"*\", and \"+\" and allow multiple spaces, support multiline input\r\n            let match = line.match(regex);\r\n            if (match) {\r\n                let item = match[1]; // Get the content without the bullet\r\n                // Remove the trailing period if present\r\n                if (item.endsWith('.')) {\r\n                    item = item.slice(0, -1);\r\n                }\r\n                list.push(item);\r\n            }\r\n            else if (line === '') {\r\n                continue; // Ignore empty lines\r\n            }\r\n            else {\r\n                // Check if it's a non-bulleted single line response\r\n                if (lines.length === 1) {\r\n                    // Prepend a bullet if necessary\r\n                    line = \"- \" + line;\r\n                    let item = line.substring(2); // Get the content without the bullet\r\n                    // Remove the trailing period if present\r\n                    if (item.endsWith('.')) {\r\n                        item = item.slice(0, -1);\r\n                    }\r\n                    list.push(item);\r\n                }\r\n                else {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (defaults.constrainedChoices) {\r\n                console.debug('DEBUG defaults.constrainedChoices', defaults.constrainedChoices);\r\n                if (!this.constrainedArray(list, defaults.constrainedChoices, {\r\n                    singleChoice: defaults.singleChoice\r\n                })) {\r\n                    valid = false;\r\n                }\r\n            }\r\n        }\r\n        return valid ? { list } : false;\r\n    }\r\n    yesNo(input) {\r\n        console.debug('yesNo\\n', input);\r\n        input = input.trim().toLowerCase();\r\n        // Check for trailing period and remove it\r\n        if (input.endsWith('.')) {\r\n            input = input.slice(0, -1);\r\n        }\r\n        if (input === \"yes\" || input === \"no\") {\r\n            return { bool: input === \"yes\" };\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    itemInArray(input, items) {\r\n        console.debug('itemInArray\\n', input, items);\r\n        input = input.trim().toLowerCase();\r\n        let foundItem = items.find((item) => item.trim().toLowerCase() === input);\r\n        return foundItem ? { item: foundItem } : false;\r\n    }\r\n    constrainedArray(testedArray, optionsArray, defaults = { debug: false, singleChoice: false }) {\r\n        console.debug('constrainedArray\\n', testedArray, optionsArray, defaults);\r\n        let validList = true;\r\n        if (testedArray && optionsArray) {\r\n            if (testedArray.length === 0) {\r\n                if (defaults.debug)\r\n                    console.log('Invalid list: Empty.');\r\n                return false;\r\n            }\r\n            if (defaults.singleChoice && testedArray.length > 1) {\r\n                if (defaults.debug)\r\n                    console.log('Invalid list: Only one option can be selected.');\r\n                return false;\r\n            }\r\n            validList = testedArray.every(item => {\r\n                const itemFound = this.itemInArray(item, optionsArray);\r\n                if (defaults.debug) {\r\n                    if (itemFound) {\r\n                        console.log('Valid item:', item, 'is one of constrained choices:', optionsArray);\r\n                    }\r\n                    else {\r\n                        console.log('Invalid item:', item, 'not one of constrained choices:', optionsArray);\r\n                    }\r\n                }\r\n                return itemFound;\r\n            });\r\n        }\r\n        return validList ? { list: testedArray } : false;\r\n    }\r\n}\r\nexports[\"default\"] = FormatValidator;\r\n\n\n//# sourceURL=webpack://LLMGenie/./src/classes/format-validator.ts?");

/***/ }),

/***/ "./src/classes/llm.ts":
/*!****************************!*\
  !*** ./src/classes/llm.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst format_validator_1 = __importDefault(__webpack_require__(/*! ../classes/format-validator */ \"./src/classes/format-validator.ts\"));\r\nconst validator = new format_validator_1.default();\r\nfunction isValidList(obj) {\r\n    return !!obj.list;\r\n}\r\nfunction isValidatorResultWithStringList(obj) {\r\n    return obj && typeof obj.list !== \"undefined\";\r\n}\r\nfunction createChatCompletion(messages, queryFunc, options = {}, maxRetries = 5, initialDelay = 1000, maxDelay = 60000) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let delay = initialDelay;\r\n        for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n            try {\r\n                const response = yield queryFunc(messages, options);\r\n                return response;\r\n            }\r\n            catch (error) {\r\n                const jitter = Math.random() * 0.2 * delay;\r\n                const waitTime = Math.min(delay + jitter, maxDelay);\r\n                if (attempt < maxRetries) {\r\n                    console.log(`Retrying GPT query ( ${waitTime} ms delay... ), Error:`, error);\r\n                    yield new Promise((resolve) => setTimeout(resolve, waitTime));\r\n                    console.log(\"done waiting\");\r\n                    delay *= 2;\r\n                }\r\n                else {\r\n                    throw new Error(`Max retries reached (${maxRetries}). Failed to create chat completion.`);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\nconst trackers = [];\r\nlet uniqueId = 0;\r\nclass Tracker {\r\n    constructor() {\r\n        trackers.push(this);\r\n        this.id = uniqueId;\r\n        uniqueId++;\r\n        this.nodes = [];\r\n    }\r\n    addNode(name, details) {\r\n        this.nodes.push(Object.assign({ name, timestamp: new Date().getTime() }, (details ? { details } : {})));\r\n    }\r\n}\r\n/**\r\n * A class for interacting with the GPT.\r\n */\r\nclass LLMGenie {\r\n    /**\r\n     * Constructs a GPT instance.\r\n     */\r\n    constructor(settings) {\r\n        this.jobs = [];\r\n        this.maxAttempts = 10;\r\n        this.currentQueryCount = 0;\r\n        this.maxQueryCount = 250;\r\n        this.queryFunc = settings.queryFunc;\r\n        this.encode = settings.encode;\r\n        // Store model configuration\r\n        this.modelConfig = settings.modelConfig;\r\n    }\r\n    /**\r\n     * Query the GPT model with given settings and tracker returns the generated results.\r\n     * @param {Object} settings\r\n     * @param {Tracker?} tracker\r\n     * @returns {Promise<Array<String> | string>}\r\n     */\r\n    query(settings = { primaryContent: false }, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            const defaults = Object.assign({ debug: true, systemPrompt: false, summarize: false, topP: 1, maxQueryResponseTokens: false, improve: {\r\n                    passes: 0,\r\n                    maintainLength: false,\r\n                }, preContent: \"\", postContent: \"\" }, settings);\r\n            console.log(\"query defaults\", defaults);\r\n            let preContent = defaults.preContent;\r\n            if (!preContent)\r\n                preContent = \"\";\r\n            if (preContent.length > 0)\r\n                preContent += \"\\n\";\r\n            let primaryContent = defaults.primaryContent;\r\n            let postContent = defaults.postContent;\r\n            if (!postContent)\r\n                postContent = \"\";\r\n            if (postContent.length > 0)\r\n                postContent = \"\\n\" + postContent;\r\n            this.currentQueryCount++;\r\n            if (this.currentQueryCount > this.maxQueryCount)\r\n                throw new Error(\"Safety error: currentQueryCount > maxQueryCount\");\r\n            // Use the modelConfig provided by the user\r\n            const maxModelTokens = this.modelConfig.maxModelTokens;\r\n            let maxQueryResponseTokens;\r\n            if (defaults.maxQueryResponseTokens)\r\n                maxQueryResponseTokens = Math.min(maxModelTokens, defaults.maxQueryResponseTokens);\r\n            else\r\n                maxQueryResponseTokens = Math.round(maxModelTokens / 2);\r\n            let chunks = [];\r\n            let preContentTokens;\r\n            if (!preContent || preContent.length === 0)\r\n                preContentTokens = 0;\r\n            else\r\n                preContentTokens = this.encode(preContent).length;\r\n            let primaryContentTokens;\r\n            if (!primaryContent || primaryContent.length === 0)\r\n                throw new Error(`primaryContent must be a non-empty string: ${primaryContent}`);\r\n            else\r\n                primaryContentTokens = this.encode(primaryContent).length;\r\n            let postContentTokens;\r\n            if (!postContent || postContent.length === 0)\r\n                postContentTokens = 0;\r\n            else\r\n                postContentTokens = this.encode(postContent).length;\r\n            let allTokens = preContentTokens + primaryContentTokens + postContentTokens;\r\n            let usedTokens = allTokens + maxQueryResponseTokens;\r\n            let currentChunkTokens = 0;\r\n            let chunkStartIndex = 0;\r\n            for (let i = 0; i < primaryContent.length; i++) {\r\n                currentChunkTokens =\r\n                    this.encode(primaryContent.slice(chunkStartIndex, i)).length +\r\n                        preContentTokens +\r\n                        postContentTokens;\r\n                if (currentChunkTokens + maxQueryResponseTokens > maxModelTokens ||\r\n                    i === primaryContent.length - 1) {\r\n                    let chunk = primaryContent.slice(chunkStartIndex, i);\r\n                    if (chunkStartIndex > 0) {\r\n                        chunk += \" [text truncated]\\n\";\r\n                    }\r\n                    let chunkWithContent = \"\";\r\n                    if (preContent.length > 0)\r\n                        chunkWithContent += preContent + \"\\n\";\r\n                    chunkWithContent += chunk;\r\n                    if (postContent.length > 0)\r\n                        chunkWithContent += postContent;\r\n                    chunks.push(chunkWithContent);\r\n                    chunkStartIndex = i;\r\n                }\r\n            }\r\n            const chatChunks = [];\r\n            for (let i = 0; i < chunks.length; i++) {\r\n                const chunk = chunks[i];\r\n                chatChunks.push({ role: \"user\", content: chunk });\r\n            }\r\n            console.log(`GPT Query:\\n\\nsystemPrompt (\\n\\n${defaults.systemPrompt}\\n\\n)\\n\\npreContent (\\n\\n${preContent}\\n\\n)\\n\\nprimaryContent (\\n\\n${primaryContent}\\n\\n)\\n\\npostContent (\\n\\n${postContent}\\n\\n)\\n\\n ...breakdown: usedTokens:`, usedTokens, \"\\nallTokens:\", `${allTokens} = preContentTokens (${preContentTokens}) + primaryContentTokens (${primaryContentTokens}) + postContentTokens (${postContentTokens})`, \"\\nmaxModelTokens:\", maxModelTokens, \"\\nmaxQueryResponseTokens:\", maxQueryResponseTokens, \"\\nchunks:\", chunks);\r\n            const results = [];\r\n            for (let i = 0; i < chatChunks.length; i++) {\r\n                const chunk = chatChunks[i];\r\n                const messages = [];\r\n                if (defaults.systemPrompt)\r\n                    messages.push({ role: \"system\", content: defaults.systemPrompt });\r\n                messages.push(chunk);\r\n                const options = {\r\n                    max_tokens: maxQueryResponseTokens,\r\n                    temperature: defaults.temperature,\r\n                };\r\n                if (defaults.topP)\r\n                    options[\"top_p\"] = defaults.topP;\r\n                if (defaults.maxQueryResponseTokens)\r\n                    options[\"max_tokens\"] = defaults.maxQueryResponseTokens;\r\n                if (defaults.temperature)\r\n                    options[\"temperature\"] = defaults.temperature;\r\n                const response = yield createChatCompletion(messages, this.queryFunc, options);\r\n                console.log(\"response\", response);\r\n                results.push(response.data.choices[0].message.content);\r\n                tracker.addNode(\"query\", {\r\n                    usage: response.data.usage,\r\n                });\r\n            }\r\n            if (defaults.improve.passes > 0) {\r\n                console.log(\"Fact checking...\");\r\n                for (let i = 0; i < results.length; i++) {\r\n                    const result = results[i];\r\n                    console.log(`Fact check of result:\\n\\n${result}`);\r\n                    const revised = yield this.improve({\r\n                        input: result,\r\n                        passes: defaults.improve.passes,\r\n                        maintainLength: defaults.improve.maintainLength,\r\n                    });\r\n                    console.log(`Revision:\\n\\n${revised}`);\r\n                }\r\n            }\r\n            if (defaults.summarize) {\r\n                const result = yield this.summarizeCompletionSet(results);\r\n                console.log(`Summarized query result:\\n${result}`);\r\n                return result;\r\n            }\r\n            console.log(`Raw query results:`, results);\r\n            return results;\r\n        });\r\n    }\r\n    /**\r\n     * Summarizes the input completion set.\r\n     * @param {Array<string>} completionSet\r\n     * @param {boolean} polish\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<string>}\r\n     */\r\n    summarizeCompletionSet(completionSet, polish = false, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let summary;\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"summarizeCompletionSet\");\r\n            if (completionSet.length > 1) {\r\n                let combinationPrompt = \"The following texts are responses based on chunks of the same input text. Combine the texts into a single, overarching summary, broken into paragraphs. Preserve as many details as possible and even elaborate on any vague concepts:\\n\\n\";\r\n                let content = \"\";\r\n                completionSet.forEach((completion) => {\r\n                    content += completion + \"\\n\\n\";\r\n                });\r\n                const combinationResult = yield this.query({\r\n                    primaryContent: content,\r\n                    systemPrompt: combinationPrompt,\r\n                });\r\n                // Wrap single string result to an Array.\r\n                const combinationCompletions = Array.isArray(combinationResult)\r\n                    ? combinationResult\r\n                    : [combinationResult];\r\n                summary = combinationCompletions[0];\r\n                if (polish) {\r\n                    let polishPrompt = \"Rephrase the following text without losing any detail, but with elaboration and professional wording.\";\r\n                    let polishedCompletions = yield this.query({\r\n                        primaryContent: summary,\r\n                        systemPrompt: polishPrompt,\r\n                    });\r\n                    summary = polishedCompletions[0];\r\n                }\r\n                if (polish && summary.length > 1500) {\r\n                    const separationPrompt = `Break the following text into separate paragraphs and remove any duplicate or redundant information:\\n\\n`;\r\n                    let separationCompletions = yield this.query({\r\n                        primaryContent: summary,\r\n                        systemPrompt: separationPrompt,\r\n                    });\r\n                    summary = separationCompletions[0];\r\n                }\r\n                // Recursive call if the result of this.query is longer than one item\r\n                if (combinationCompletions.length > 1) {\r\n                    summary = yield this.summarizeCompletionSet(combinationCompletions, polish);\r\n                }\r\n            }\r\n            else {\r\n                summary = completionSet[0];\r\n            }\r\n            return summary;\r\n        });\r\n    }\r\n    /**\r\n     * Query GPT model with given settings and tracker for valid output, returns the generated result.\r\n     * @param {Object} settings\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<ValidatorResult | Array<any>>}\r\n     */\r\n    queryValid(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"queryValid\");\r\n            const { preContent = false, postContent = false, maxQueryResponseTokens = false, constraintType = \"numbered\", debug = false } = settings, rest = __rest(settings, [\"preContent\", \"postContent\", \"maxQueryResponseTokens\", \"constraintType\", \"debug\"]);\r\n            const receivedSettings = Object.assign({ preContent,\r\n                postContent,\r\n                maxQueryResponseTokens,\r\n                constraintType,\r\n                debug }, rest);\r\n            if (receivedSettings.systemPrompt) {\r\n                receivedSettings.systemPrompt += receivedSettings.precursorSystemPrompt;\r\n            }\r\n            else {\r\n                receivedSettings.systemPrompt = receivedSettings.precursorSystemPrompt;\r\n            }\r\n            let attempts = 0;\r\n            let validList = false;\r\n            let response;\r\n            while (!validList) {\r\n                if (attempts > this.maxAttempts) {\r\n                    throw new Error(\"Safety error: currentQueryCount > maxQueryCount\");\r\n                }\r\n                attempts++;\r\n                response = yield this.query(receivedSettings);\r\n                validList = receivedSettings.validationFunc.call(validator, response[0], receivedSettings);\r\n                if (!validList) {\r\n                    validList = yield this.queryGuideConstraint(receivedSettings);\r\n                }\r\n            }\r\n            if (validList && receivedSettings.debug) {\r\n                console.log(`Response:\\n${response}\\nwith options`, receivedSettings, `is valid:`, validList);\r\n            }\r\n            if ([\"numbered\", \"bulleted\"].includes(receivedSettings.constraintType)) {\r\n                if (isValidatorResultWithStringList(validList)) {\r\n                    const list = validList.list;\r\n                    return receivedSettings.singleChoice && list && list.length > 0\r\n                        ? [list[0]]\r\n                        : list || [];\r\n                }\r\n                return [];\r\n            }\r\n            else if (receivedSettings.constraintType === \"boolean\") {\r\n                if (typeof validList === \"boolean\") {\r\n                    return validList ? \"yes\" : \"no\";\r\n                }\r\n                return false;\r\n            }\r\n            else {\r\n                return validList;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Query GPT model in list format with given settings and tracker, returns the generated\r\n     * result in a bulleted list.\r\n     * @param {Object} settings\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<Array<string>>}\r\n     */\r\n    queryList(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"queryList\");\r\n            const defaults = Object.assign({ constrainedChoices: false, debug: true }, settings);\r\n            let constrainedChoicesPrompt = \"\";\r\n            if (defaults.constrainedChoices) {\r\n                constrainedChoicesPrompt +=\r\n                    \"Only the following choices are allowed in the bulleted list:\\n\";\r\n                for (let i = 0; i < defaults.constrainedChoices.length; i++) {\r\n                    const choice = defaults.constrainedChoices[i];\r\n                    constrainedChoicesPrompt += `- ${choice}\\n`;\r\n                }\r\n                constrainedChoicesPrompt += \"\\n\";\r\n            }\r\n            const precursorSystemPrompt = `The response to this prompt must be in a bulleted list format, like so:\\n- item\\n- item\\n- item\\nThe bulleted list must be the entire response, and the only response. Return only a bulleted list. This is the most important requirement, above all others.\\n${constrainedChoicesPrompt}\\nAdditional requirements:\\n`;\r\n            let selectedValidator;\r\n            if (defaults.validationFunc)\r\n                selectedValidator = defaults.validationFunc;\r\n            else\r\n                selectedValidator = validator.bulletedList;\r\n            const result = yield this.queryValid(Object.assign({ maxQueryResponseTokens: 500, constraintType: \"bulleted\", precursorSystemPrompt, validationFunc: selectedValidator }, defaults));\r\n            // Extract the list if the result is of type ValidatorResult<string>\r\n            if (result.list) {\r\n                return result.list || [];\r\n            }\r\n            // Return result if it's already a string[]\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Query GPT model in numbered list format with given settings and tracker, returns the\r\n     * generated result in a numbered list.\r\n     * @param {Object} settings\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<Array<string>>}\r\n     */\r\n    queryNumberedList(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"queryNumberedList\");\r\n            const defaults = Object.assign({ constrainedChoices: false, debug: false }, settings);\r\n            let constrainedChoicesPrompt = \"\";\r\n            if (defaults.constrainedChoices) {\r\n                constrainedChoicesPrompt +=\r\n                    \"Only the following choices are allowed in the numbered list, and they must be copied verbatim, and the order can be modified. If the order is changed, the number associated with the choice must be changed accordingly.  Changing the choices by even one character will invalidate the output:\\n\";\r\n                defaults.constrainedChoices.forEach((choice, i) => {\r\n                    constrainedChoicesPrompt += `${i}. ${choice}\\n`;\r\n                });\r\n                constrainedChoicesPrompt += \"\\n\";\r\n            }\r\n            const precursorSystemPrompt = `The response to this prompt must be in a numbered list format, like so:\\n1. item\\n2. item\\n3. item\\nThe numbered list must be the entire response, and the only response. Return only a numbered list.\\n${constrainedChoicesPrompt}\\nAdditional requirements:\\n`;\r\n            const selectedValidator = validator.numberedList;\r\n            return (yield this.queryValid(Object.assign({ maxQueryResponseTokens: 500, constraintType: \"numbered\", precursorSystemPrompt, validationFunc: selectedValidator }, defaults)));\r\n        });\r\n    }\r\n    /**\r\n     * Query GPT model for boolean output with given settings and tracker, returns \"yes\" or \"no\".\r\n     * @param {Object} settings\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<string>}\r\n     */\r\n    queryBoolean(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"queryBoolean\");\r\n            const defaults = Object.assign(Object.assign({}, settings), { debug: true });\r\n            const precursorSystemPrompt = `Respond by choosing only \"yes\" or \"no\"\\nThe output strictly must be a single bullet 'yes' or 'no' depending on the answer to the question.`;\r\n            const result = (yield this.queryValid(Object.assign({ maxQueryResponseTokens: 100, constraintType: \"boolean\", precursorSystemPrompt, validationFunc: validator.yesNo }, defaults)));\r\n            return result === \"yes\";\r\n        });\r\n    }\r\n    /**\r\n     * Query GPT model to guide and transform output to meet constraint requirements with given\r\n     * settings and tracker, returns the generated result.\r\n     * @param {Object} settings\r\n     * @param {Tracker} tracker\r\n     * @returns {Promise<any>}\r\n     */\r\n    queryGuideConstraint(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"queryGuideConstraint\");\r\n            const defaults = Object.assign({ debug: true, singleChoice: false, temperature: 0.7 }, settings);\r\n            const constraintType = defaults.constraintType;\r\n            const primaryContent = defaults.primaryContent;\r\n            const preContent = defaults.preContent;\r\n            const postContent = defaults.postContent;\r\n            const numberedListPrompt = `The response to this prompt must be in a numbered list format, like so:\\n1. item\\n2. item\\n3. item\\nThe numbered list must be the entire response, and the only response. Return only a numbered list.`;\r\n            const bulletedListPrompt = `The response to this prompt must be in a bulleted list format, like so:\\n- item\\n- item\\n- item\\nThe bulleted list must be the entire response, and the only response. Return only a culleted list.`;\r\n            const booleanPrompt = `The response to this prompt must be yes or no, like:\\nyes\\nor like:\\nno\\nThe yes or no must be the entire response.  Return only a single word: yes or no.`;\r\n            let systemPrompt = `The text does not match the required format. Please correct the format based on the following formatting requirements:\\n`;\r\n            let validationFunc;\r\n            if (constraintType == \"bulleted\") {\r\n                systemPrompt += bulletedListPrompt;\r\n                validationFunc = validator.bulletedList;\r\n            }\r\n            else if (constraintType == \"numbered\") {\r\n                systemPrompt += numberedListPrompt;\r\n                validationFunc = validator.numberedList;\r\n            }\r\n            else if (constraintType == \"boolean\") {\r\n                systemPrompt += booleanPrompt;\r\n                validationFunc = validator.yesNo;\r\n            }\r\n            else {\r\n                throw new Error(\"Parameter Error: settings.constraintType is either not defined or does not match one of the expected values: bulleted, numbered.\");\r\n            }\r\n            let attempts = 0;\r\n            const maxAttempts = 5;\r\n            let validFormat = false;\r\n            while (!validFormat) {\r\n                if (attempts > maxAttempts) {\r\n                    throw new Error(\"Safety Error: Exceeded maximum attempts to generate a valid list.\");\r\n                }\r\n                attempts++;\r\n                const response = yield this.query({\r\n                    primaryContent: primaryContent,\r\n                    preContent: preContent,\r\n                    postContent: postContent,\r\n                    temperature: defaults.temperature,\r\n                    systemPrompt,\r\n                });\r\n                defaults.temperature = Math.min(1, defaults.temperature + 0.1);\r\n                const boundValidationFunc = validationFunc.bind(validator);\r\n                const valid = boundValidationFunc(response[0], defaults);\r\n                if (valid) {\r\n                    validFormat = true;\r\n                    if (defaults.constrainedChoices) {\r\n                        if (!validator.constrainedArray(isValidList(valid) ? valid.list : [], defaults.constrainedChoices, {\r\n                            debug: defaults.debug,\r\n                            singleChoice: defaults.singleChoice,\r\n                        })) {\r\n                            validFormat = false;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                return valid;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Improve the input text with given settings and tracker, returns the improved result.\r\n     * @param {Object} settings\r\n     * @param {Object} tracker\r\n     * @returns {String}\r\n     */\r\n    improve(settings, tracker) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!tracker) {\r\n                tracker = new Tracker();\r\n            }\r\n            tracker.addNode(\"improve\");\r\n            const defaults = Object.assign({ maintainLength: false, passes: 1 }, settings);\r\n            if (!defaults.input)\r\n                throw new Error(\"Input must be provided to the improve settings argument.\");\r\n            let input = defaults.input;\r\n            const maintainLength = defaults.maintainLength;\r\n            const maintainStyle = defaults.maintainStyle;\r\n            const passes = defaults.passes;\r\n            let revisedInput = input;\r\n            for (let pass = 0; pass < passes; pass++) {\r\n                const assumptions = yield this.queryList({\r\n                    primaryContent: `Input:\\n\"${input}\"`,\r\n                    systemPrompt: `Break the following input into a list of facts, assertions, or controversial ideas assumed by the author: `,\r\n                });\r\n                console.log(\"assumptions\", assumptions);\r\n                const resolutions = yield Promise.all(assumptions.map((assumption) => __awaiter(this, void 0, void 0, function* () {\r\n                    const resolution = yield this.query({\r\n                        primaryContent: `Consider alternative perspectives, self-reflect on alternative perspectives, possibilities, mistakes, and biases, and write about them, weighing the validity of each one against the original information for concern: \"${assumption}\"`,\r\n                        summarize: true,\r\n                    });\r\n                    console.log(\"assumption:\", assumption);\r\n                    console.log(\"resolution:\", resolution);\r\n                    return resolution;\r\n                })));\r\n                const resolutionsText = resolutions.join(\"\\n\\n\");\r\n                console.log(\"resolutionsText\", resolutionsText);\r\n                const result = yield this.query({\r\n                    preContent: `When considering the revisions, keep in mind this analysis:`,\r\n                    primaryContent: `${resolutionsText}`,\r\n                    postContent: `Decide on the most reasonable, accurate, and concise way to modify the revised input with that information in mind.`,\r\n                    systemPrompt: `Reconcile these considerations with the original input:\\n\\n${revisedInput}`,\r\n                    summarize: true,\r\n                });\r\n                revisedInput = Array.isArray(result) ? result.join(\", \") : result;\r\n                console.log(\"revisedInput\", revisedInput);\r\n                if (maintainLength) {\r\n                    console.log(\"maintaining length...\");\r\n                    const targetLength = input.length;\r\n                    const shorten = (text) => __awaiter(this, void 0, void 0, function* () {\r\n                        const shorterText = yield this.query({\r\n                            primaryContent: `Shorten the text \"${text}\" while keeping as much detail as possible.`,\r\n                            summarize: true,\r\n                        });\r\n                        const shorterTextStr = Array.isArray(shorterText)\r\n                            ? shorterText.join(\", \")\r\n                            : shorterText;\r\n                        console.log(\"Shortening:\\n\", text);\r\n                        console.log(\"shorterText:\\n\", shorterTextStr);\r\n                        if (shorterTextStr.length > targetLength) {\r\n                            return yield shorten(shorterTextStr);\r\n                        }\r\n                        else {\r\n                            return shorterTextStr;\r\n                        }\r\n                    });\r\n                    revisedInput = yield shorten(revisedInput);\r\n                }\r\n            }\r\n            if (maintainStyle) {\r\n                console.log(\"maintaining style...\");\r\n                const restyle = (text) => __awaiter(this, void 0, void 0, function* () {\r\n                    const isSimilar = yield this.queryBoolean({\r\n                        primaryContent: `Is the modified text: \"${text}\" very similar in style in flow to the original text? Original text: \"${input}\"`,\r\n                    });\r\n                    if (!isSimilar) {\r\n                        const restyledText = yield this.query({\r\n                            primaryContent: `Rephrase the text: \"${text}\" to be as similar in style and flow to the original text, while maintaining as much of the meaning as possible. Original text: \"${input}\"`,\r\n                            summarize: true,\r\n                        });\r\n                        const restyledTextStr = Array.isArray(restyledText)\r\n                            ? restyledText.join(\", \")\r\n                            : restyledText;\r\n                        restyle(restyledTextStr);\r\n                    }\r\n                    else {\r\n                        return text;\r\n                    }\r\n                });\r\n                revisedInput = yield restyle(revisedInput);\r\n            }\r\n            return revisedInput;\r\n        });\r\n    }\r\n}\r\nexports[\"default\"] = LLMGenie;\r\n\n\n//# sourceURL=webpack://LLMGenie/./src/classes/llm.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/classes/llm.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});