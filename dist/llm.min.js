!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.LLMGenie=t():e.LLMGenie=t()}(this,(function(){return function(){"use strict";var e={369:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(){this.test=!0}numberedList(e,t={}){if(console.debug("numberedList\n",e,t),"string"!=typeof e)throw new Error("Bad input supplied to numberedList: "+e);if(!e)return!1;let n=(e=e.trim()).split(/\n+/),o=[],s=!0;for(let e=0;e<n.length;e++){let t=n[e].trim(),i=new RegExp(`^${e+1}\\.?\\s+([\\s\\S]+)$`,"m"),r=t.match(i);if(!r){if(""===t)continue;s=!1;break}o.push(r[1])}return console.debug("defaults",t),t.constrainedChoices&&(console.debug("DEBUG defaults.constrainedChoices",t.constrainedChoices),this.constrainedArray(o,t.constrainedChoices,{singleChoice:t.singleChoice})||(s=!1)),!!s&&{list:o}}bulletedList(e,t){if(console.debug("bulletedList\n",e,t),!e)return!1;let n=(e=e.trim()).split(/\n+/),o=[],s=!0;for(let e of n){e=e.trim();let i=/^[-*+]\s+([\s\S]+)$/m,r=e.match(i);if(r){let e=r[1];e.endsWith(".")&&(e=e.slice(0,-1)),o.push(e)}else{if(""===e)continue;if(1!==n.length){s=!1;break}{e="- "+e;let t=e.substring(2);t.endsWith(".")&&(t=t.slice(0,-1)),o.push(t)}}t.constrainedChoices&&(console.debug("DEBUG defaults.constrainedChoices",t.constrainedChoices),this.constrainedArray(o,t.constrainedChoices,{singleChoice:t.singleChoice})||(s=!1))}return!!s&&{list:o}}yesNo(e){return console.debug("yesNo\n",e),(e=e.trim().toLowerCase()).endsWith(".")&&(e=e.slice(0,-1)),("yes"===e||"no"===e)&&{bool:"yes"===e}}itemInArray(e,t){console.debug("itemInArray\n",e,t),e=e.trim().toLowerCase();let n=t.find((t=>t.trim().toLowerCase()===e));return!!n&&{item:n}}constrainedArray(e,t,n={debug:!1,singleChoice:!1}){console.debug("constrainedArray\n",e,t,n);let o=!0;if(e&&t){if(0===e.length)return n.debug&&console.log("Invalid list: Empty."),!1;if(n.singleChoice&&e.length>1)return n.debug&&console.log("Invalid list: Only one option can be selected."),!1;o=e.every((e=>{const o=this.itemInArray(e,t);return n.debug&&(o?console.log("Valid item:",e,"is one of constrained choices:",t):console.log("Invalid item:",e,"not one of constrained choices:",t)),o}))}return!!o&&{list:e}}}},597:function(e,t,n){var o=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))((function(s,i){function r(e){try{l(o.next(e))}catch(e){i(e)}}function a(e){try{l(o.throw(e))}catch(e){i(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,a)}l((o=o.apply(e,t||[])).next())}))},s=this&&this.__rest||function(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=new(i(n(369)).default);function a(e,t,n=5,s=1e3,i=6e4){return o(this,void 0,void 0,(function*(){let o=s;for(let s=1;s<=n;s++)try{return yield t(e)}catch(e){const t=.2*Math.random()*o,r=Math.min(o+t,i);if(!(s<n))throw new Error(`Max retries reached (${n}). Failed to create chat completion.`);console.log(`Retrying GPT query ( ${r} ms delay... ), Error:`,e),yield new Promise((e=>setTimeout(e,r))),console.log("done waiting"),o*=2}}))}const l=[];let u=0;class c{constructor(){l.push(this),this.id=u,u++,this.nodes=[]}addNode(e,t){this.nodes.push(Object.assign({name:e,timestamp:(new Date).getTime()},t?{details:t}:{}))}}t.default=class{constructor(e){this.jobs=[],this.maxAttempts=10,this.currentQueryCount=0,this.maxQueryCount=250,this.queryFunc=e.queryFunc,this.encode=e.encode,this.modelConfig=e.modelConfig}query(e={primaryContent:!1},t){return o(this,void 0,void 0,(function*(){t||(t=new c);const n=Object.assign({debug:!0,systemPrompt:!1,summarize:!1,topP:1,maxQueryResponseTokens:!1,improve:{passes:0,maintainLength:!1},preContent:"",postContent:""},e);console.log("query defaults",n);let o=n.preContent;o||(o=""),o.length>0&&(o+="\n");let s=n.primaryContent,i=n.postContent;if(i||(i=""),i.length>0&&(i="\n"+i),this.currentQueryCount++,this.currentQueryCount>this.maxQueryCount)throw new Error("Safety error: currentQueryCount > maxQueryCount");const r=this.modelConfig.maxModelTokens;let l;l=n.maxQueryResponseTokens?Math.min(r,n.maxQueryResponseTokens):Math.round(r/2);let u,d,m,h=[];if(u=o&&0!==o.length?this.encode(o).length:0,!s||0===s.length)throw new Error(`primaryContent must be a non-empty string: ${s}`);d=this.encode(s).length,m=i&&0!==i.length?this.encode(i).length:0;let p=u+d+m,y=p+l,g=0,f=0;for(let e=0;e<s.length;e++)if(g=this.encode(s.slice(f,e)).length+u+m,g+l>r||e===s.length-1){let t=s.slice(f,e);f>0&&(t+=" [text truncated]\n");let n="";o.length>0&&(n+=o+"\n"),n+=t,i.length>0&&(n+=i),h.push(n),f=e}const b=[];for(let e=0;e<h.length;e++){const t=h[e];b.push({role:"user",content:t})}console.log(`GPT Query:\n\nsystemPrompt (\n\n${n.systemPrompt}\n\n)\n\npreContent (\n\n${o}\n\n)\n\nprimaryContent (\n\n${s}\n\n)\n\npostContent (\n\n${i}\n\n)\n\n ...breakdown: usedTokens:`,y,"\nallTokens:",`${p} = preContentTokens (${u}) + primaryContentTokens (${d}) + postContentTokens (${m})`,"\nmaxModelTokens:",r,"\nmaxQueryResponseTokens:",l,"\nchunks:",h);const C=[];for(let e=0;e<b.length;e++){const o=b[e],s=[];n.systemPrompt&&s.push({role:"system",content:n.systemPrompt}),s.push(o);const i={messages:s,max_tokens:l,temperature:n.temperature};n.topP&&(i.top_p=n.topP),n.maxQueryResponseTokens&&(i.max_tokens=n.maxQueryResponseTokens),n.temperature&&(i.temperature=n.temperature);const r=yield a(i,this.queryFunc);console.log("response",r),C.push(r.data.choices[0].message.content),t.addNode("query",{usage:r.data.usage})}if(n.improve.passes>0){console.log("Fact checking...");for(let e=0;e<C.length;e++){const t=C[e];console.log(`Fact check of result:\n\n${t}`);const o=yield this.improve({input:t,passes:n.improve.passes,maintainLength:n.improve.maintainLength});console.log(`Revision:\n\n${o}`)}}if(n.summarize){const e=yield this.summarizeCompletionSet(C);return console.log(`Summarized query result:\n${e}`),e}return console.log("Raw query results:",C),C}))}summarizeCompletionSet(e,t=!1,n){return o(this,void 0,void 0,(function*(){let o;if(n||(n=new c),n.addNode("summarizeCompletionSet"),e.length>1){let n="The following texts are responses based on chunks of the same input text. Combine the texts into a single, overarching summary, broken into paragraphs. Preserve as many details as possible and even elaborate on any vague concepts:\n\n",s="";e.forEach((e=>{s+=e+"\n\n"}));const i=yield this.query({primaryContent:s,systemPrompt:n}),r=Array.isArray(i)?i:[i];if(o=r[0],t){let e="Rephrase the following text without losing any detail, but with elaboration and professional wording.";o=(yield this.query({primaryContent:o,systemPrompt:e}))[0]}if(t&&o.length>1500){const e="Break the following text into separate paragraphs and remove any duplicate or redundant information:\n\n";o=(yield this.query({primaryContent:o,systemPrompt:e}))[0]}r.length>1&&(o=yield this.summarizeCompletionSet(r,t))}else o=e[0];return o}))}queryValid(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("queryValid");const{preContent:n=!1,postContent:o=!1,maxQueryResponseTokens:i=!1,constraintType:a="numbered",debug:l=!1}=e,u=s(e,["preContent","postContent","maxQueryResponseTokens","constraintType","debug"]),d=Object.assign({preContent:n,postContent:o,maxQueryResponseTokens:i,constraintType:a,debug:l},u);d.systemPrompt?d.systemPrompt+=d.precursorSystemPrompt:d.systemPrompt=d.precursorSystemPrompt;let m,h=0,p=!1;for(;!p;){if(h>this.maxAttempts)throw new Error("Safety error: currentQueryCount > maxQueryCount");h++,m=yield this.query(d),p=d.validationFunc.call(r,m[0],d),p||(p=yield this.queryGuideConstraint(d))}if(p&&d.debug&&console.log(`Response:\n${m}\nwith options`,d,"is valid:",p),["numbered","bulleted"].includes(d.constraintType)){if((y=p)&&void 0!==y.list){const e=p.list;return d.singleChoice&&e&&e.length>0?[e[0]]:e||[]}return[]}return"boolean"===d.constraintType?"boolean"==typeof p&&(p?"yes":"no"):p;var y}))}queryList(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("queryList");const n=Object.assign({constrainedChoices:!1,debug:!0},e);let o="";if(n.constrainedChoices){o+="Only the following choices are allowed in the bulleted list:\n";for(let e=0;e<n.constrainedChoices.length;e++)o+=`- ${n.constrainedChoices[e]}\n`;o+="\n"}const s=`The response to this prompt must be in a bulleted list format, like so:\n- item\n- item\n- item\nThe bulleted list must be the entire response, and the only response. Return only a bulleted list. This is the most important requirement, above all others.\n${o}\nAdditional requirements:\n`;let i;i=n.validationFunc?n.validationFunc:r.bulletedList;const a=yield this.queryValid(Object.assign({maxQueryResponseTokens:500,constraintType:"bulleted",precursorSystemPrompt:s,validationFunc:i},n));return a.list?a.list||[]:a}))}queryNumberedList(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("queryNumberedList");const n=Object.assign({constrainedChoices:!1,debug:!1},e);let o="";n.constrainedChoices&&(o+="Only the following choices are allowed in the numbered list, and they must be copied verbatim, and the order can be modified. If the order is changed, the number associated with the choice must be changed accordingly.  Changing the choices by even one character will invalidate the output:\n",n.constrainedChoices.forEach(((e,t)=>{o+=`${t}. ${e}\n`})),o+="\n");const s=`The response to this prompt must be in a numbered list format, like so:\n1. item\n2. item\n3. item\nThe numbered list must be the entire response, and the only response. Return only a numbered list.\n${o}\nAdditional requirements:\n`,i=r.numberedList;return yield this.queryValid(Object.assign({maxQueryResponseTokens:500,constraintType:"numbered",precursorSystemPrompt:s,validationFunc:i},n))}))}queryBoolean(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("queryBoolean");const n=Object.assign(Object.assign({},e),{debug:!0});return"yes"===(yield this.queryValid(Object.assign({maxQueryResponseTokens:100,constraintType:"boolean",precursorSystemPrompt:"Respond by choosing only \"yes\" or \"no\"\nThe output strictly must be a single bullet 'yes' or 'no' depending on the answer to the question.",validationFunc:r.yesNo},n)))}))}queryGuideConstraint(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("queryGuideConstraint");const n=Object.assign({debug:!0,singleChoice:!1,temperature:.7},e),o=n.constraintType,s=n.primaryContent,i=n.preContent,a=n.postContent;let l,u="The text does not match the required format. Please correct the format based on the following formatting requirements:\n";if("bulleted"==o)u+="The response to this prompt must be in a bulleted list format, like so:\n- item\n- item\n- item\nThe bulleted list must be the entire response, and the only response. Return only a culleted list.",l=r.bulletedList;else if("numbered"==o)u+="The response to this prompt must be in a numbered list format, like so:\n1. item\n2. item\n3. item\nThe numbered list must be the entire response, and the only response. Return only a numbered list.",l=r.numberedList;else{if("boolean"!=o)throw new Error("Parameter Error: settings.constraintType is either not defined or does not match one of the expected values: bulleted, numbered.");u+="The response to this prompt must be yes or no, like:\nyes\nor like:\nno\nThe yes or no must be the entire response.  Return only a single word: yes or no.",l=r.yesNo}let d=0,m=!1;for(;!m;){if(d>5)throw new Error("Safety Error: Exceeded maximum attempts to generate a valid list.");d++;const e=yield this.query({primaryContent:s,preContent:i,postContent:a,temperature:n.temperature,systemPrompt:u});n.temperature=Math.min(1,n.temperature+.1);const t=l.bind(r)(e[0],n);if(!t||(m=!0,!n.constrainedChoices||r.constrainedArray(t.list?t.list:[],n.constrainedChoices,{debug:n.debug,singleChoice:n.singleChoice})))return t;m=!1}}))}improve(e,t){return o(this,void 0,void 0,(function*(){t||(t=new c),t.addNode("improve");const n=Object.assign({maintainLength:!1,passes:1},e);if(!n.input)throw new Error("Input must be provided to the improve settings argument.");let s=n.input;const i=n.maintainLength,r=n.maintainStyle,a=n.passes;let l=s;for(let e=0;e<a;e++){const e=yield this.queryList({primaryContent:`Input:\n"${s}"`,systemPrompt:"Break the following input into a list of facts, assertions, or controversial ideas assumed by the author: "});console.log("assumptions",e);const t=(yield Promise.all(e.map((e=>o(this,void 0,void 0,(function*(){const t=yield this.query({primaryContent:`Consider alternative perspectives, self-reflect on alternative perspectives, possibilities, mistakes, and biases, and write about them, weighing the validity of each one against the original information for concern: "${e}"`,summarize:!0});return console.log("assumption:",e),console.log("resolution:",t),t})))))).join("\n\n");console.log("resolutionsText",t);const n=yield this.query({preContent:"When considering the revisions, keep in mind this analysis:",primaryContent:`${t}`,postContent:"Decide on the most reasonable, accurate, and concise way to modify the revised input with that information in mind.",systemPrompt:`Reconcile these considerations with the original input:\n\n${l}`,summarize:!0});if(l=Array.isArray(n)?n.join(", "):n,console.log("revisedInput",l),i){console.log("maintaining length...");const e=s.length,t=n=>o(this,void 0,void 0,(function*(){const o=yield this.query({primaryContent:`Shorten the text "${n}" while keeping as much detail as possible.`,summarize:!0}),s=Array.isArray(o)?o.join(", "):o;return console.log("Shortening:\n",n),console.log("shorterText:\n",s),s.length>e?yield t(s):s}));l=yield t(l)}}if(r){console.log("maintaining style...");const e=t=>o(this,void 0,void 0,(function*(){if(yield this.queryBoolean({primaryContent:`Is the modified text: "${t}" very similar in style in flow to the original text? Original text: "${s}"`}))return t;{const n=yield this.query({primaryContent:`Rephrase the text: "${t}" to be as similar in style and flow to the original text, while maintaining as much of the meaning as possible. Original text: "${s}"`,summarize:!0}),o=Array.isArray(n)?n.join(", "):n;e(o)}}));l=yield e(l)}return l}))}}}},t={},n=function n(o){var s=t[o];if(void 0!==s)return s.exports;var i=t[o]={exports:{}};return e[o].call(i.exports,i,i.exports,n),i.exports}(597);return n.default}()}));